# walk.py (v7 - Adaptive Speed Control)
#
# NEW FEATURE:
# The robot now adjusts its forward speed based on how clear the path ahead is.
# - Long, open corridors -> FAST_SPEED
# - Moderately clear paths -> NORMAL_SPEED
# - Narrow but safe paths -> SLOW_SPEED

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
import math

class AdaptiveSpeedWalker(Node):
    def __init__(self):
        super().__init__('adaptive_speed_walker')
        
        # Publishers and Subscribers
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.scan_sub = self.create_subscription(LaserScan, '/base_scan', self.sensor_callback, 10)
        self.odom_sub = self.create_subscription(Odometry, '/ground_truth', self.odometry_callback, 10)
        
        # Main logic timer
        self.timer = self.create_timer(0.1, self.run_logic_loop)

        # --- [MODIFIED] Constants ---
        self.TARGET_DISTANCE = 19.0      # Remember to set this for each starting position!
        self.ROTATION_SPEED = 0.8
        self.FRONT_THRESHOLD = 0.7       # The closest it can get before turning

        # --- [NEW] Adaptive Speed Constants (Feel free to tune these!) ---
        self.SLOW_SPEED = 0.3            # Speed for narrow corridors
        self.NORMAL_SPEED = 0.6          # Standard speed
        self.FAST_SPEED = 0.9            # Speed for wide-open areas

        # --- [NEW] Distance Thresholds for Speed Changes ---
        self.NORMAL_SPEED_THRESHOLD = 1.5 # Min distance for NORMAL_SPEED
        self.FAST_SPEED_THRESHOLD = 3.0   # Min distance for FAST_SPEED

        # --- State and Command Variables ---
        self.target_linear_velocity = 0.0
        self.target_angular_velocity = 0.0
        
        # --- Position and Goal Tracking ---
        self.start_pos = None
        self.current_distance = 0.0
        self.previous_distance = 0.0
        self.goal_reached = False
        self.latest_scan = None
        
        self.get_logger().info(f"AdaptiveSpeedWalker started. Target: {self.TARGET_DISTANCE}m")

    def odometry_callback(self, msg):
        """Processes odometry data to update the robot's current distance from start."""
        if self.start_pos is None:
            self.start_pos = (msg.pose.pose.position.x, msg.pose.pose.position.y)
        self.current_distance = math.sqrt((msg.pose.pose.position.x - self.start_pos[0])**2 + (msg.pose.pose.position.y - self.start_pos[1])**2)
        if self.current_distance >= self.TARGET_DISTANCE and not self.goal_reached:
            self.goal_reached = True
            self.get_logger().info(f"SUCCESS: Goal of {self.TARGET_DISTANCE}m reached! Stopping.")

    def sensor_callback(self, msg):
        """Callback to simply store the latest sensor data."""
        self.latest_scan = msg

    def run_logic_loop(self):
        """This function is called by the timer and contains the main decision logic."""
        if self.latest_scan is None or self.start_pos is None:
            return

        if self.goal_reached:
            self.target_linear_velocity = 0.0
            self.target_angular_velocity = 0.0
        else:
            front_view = self.latest_scan.ranges[60:121]
            left_view = self.latest_scan.ranges[121:171]
            right_view = self.latest_scan.ranges[10:60]
            min_dist_front = min([r for r in front_view if not math.isinf(r)] or [100])
            min_dist_left = min([r for r in left_view if not math.isinf(r)] or [100])
            min_dist_right = min([r for r in right_view if not math.isinf(r)] or [100])

            if min_dist_front < self.FRONT_THRESHOLD:
                self.get_logger().info(f"Path blocked by obstacle at {min_dist_front:.2f}m. Turning.")
                self.target_linear_velocity = 0.0
                if min_dist_left > min_dist_right:
                    self.target_angular_velocity = self.ROTATION_SPEED
                else:
                    self.target_angular_velocity = -self.ROTATION_SPEED
            
            elif self.current_distance < self.previous_distance - 0.001:
                self.get_logger().warn(f"Distance decreased. Forcing a turn!")
                self.target_linear_velocity = 0.0
                self.target_angular_velocity = self.ROTATION_SPEED
                
            # --- [MODIFIED] Default behavior with adaptive speed ---
            else:
                self.target_angular_velocity = 0.0 # Always go straight
                # Decide speed based on how clear the path is
                if min_dist_front > self.FAST_SPEED_THRESHOLD:
                    self.target_linear_velocity = self.FAST_SPEED
                    self.get_logger().info(f"Path clear for {min_dist_front:.2f}m. Engaging FAST speed.")
                elif min_dist_front > self.NORMAL_SPEED_THRESHOLD:
                    self.target_linear_velocity = self.NORMAL_SPEED
                    self.get_logger().info(f"Path clear for {min_dist_front:.2f}m. Engaging NORMAL speed.")
                else:
                    self.target_linear_velocity = self.SLOW_SPEED
                    self.get_logger().info(f"Path is narrow ({min_dist_front:.2f}m). Engaging SLOW speed.")

        self.publish_command()
        self.previous_distance = self.current_distance

    def publish_command(self):
        """Creates and publishes the Twist message based on the target velocities."""
        twist_msg = Twist()
        twist_msg.linear.x = self.target_linear_velocity
        twist_msg.angular.z = self.target_angular_velocity
        self.cmd_pub.publish(twist_msg)

def main(args=None):
    rclpy.init(args=args)
    walker_node = AdaptiveSpeedWalker()
    rclpy.spin(walker_node)
    walker_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
